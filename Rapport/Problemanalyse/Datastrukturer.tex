\section{Datastruktur}
\label{sec:datastruktur}
I implementeringen af ethvert kort må den bagvedliggende datastruktur nøje overvejes, da denne i høj grad afgør applikationens ressourcekrav. Overvejelserne omkring datastrukturen involverede blandt andet muligheden for kun at indlæse specifikke dele af dataet samt søgeegenskaber. Det givne datasæt består af knudepunkter og tilhørende vejsegmenter, som forbinder to af disse knudepunkter. Knudepunkterne indeholder information om deres individuelle placering, mens vejsegmenterne er forbundet med en række forskellige oplysninger såsom vejnavn og -type. Da kortdataet består af vejsegmenter, er det også af betydning for valget af datastruktur. Værd at overveje var også datastørrelsen --- datakilden fra Krak indeholder over en million knudepunkter, og disse skal på ethvert tidspunkt under programkørslen kunne tilgås, hurtigt.

Flere forskellige datastrukturer syntes besidde de nævnte egenskaber: heriblandt en sorteret tabel, et k-d træ og en quadtree-struktur. Den sorterede tabel brillerer med en ukompliceret implementering. Quadtree og k-d træ, mens komplicerede at implementere, udmærker sig derimod ved deres simple datasegmentering samt hastige indlæsning af specifikke områder.

K-d træet splittes ved median elementet og opdeler træet i to subproblemer. Der splittes igen omkring median elementet i hvert subproblem, hvortil der opstår to subproblemer per split. I en quadtree-struktur, derimod, indeholder hver \emph{quad} fire andre quads --- NØ, SØ, SV og NV. Individuelle quads kan acceptere et begrænset antal elementer, hvorefter ethvert fremtidigt forsøg på indsættelse vil blive videregivet til dennes indholdte quads rekursivt.
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.4\textwidth]{quadtree1}
	\captionsetup{width=0.8\textwidth}
	\caption{Eksempel på udsnit en quadtree-struktur hvori dybden af de individuelle quads fremhæves af disses nuance.}
	\label{fig:quadtree1}
\end{figure}
Elementforespørgsel, hvor et rektangulært område søges, foregår ligeledes rekursivt. En quad, som modtager en forespørgsel, vil forespørge sine indholdte quads om selvsamme, og derefter returnere resultatet af dette sammenlagt med sine egne elementer.

Det vurderes at en sorteret liste ville være for langsom til vores behov. Det var svært at sætte fingeren på en konkret forskel i ydeevnen mellem k-d træet og quadtree-strukturen. Grundet et langt større kendskab til quadtree-strukturens virkemåde, sås denne således som den mest passende løsning. Vi fandt det vigtigt at vælge og udarbejde datastrukturen hurtigt, da udviklingen af resten af programmet afhang deraf.

\subsection{Linjeplacering}
Da en quadtree-struktur arbejder med et koordinatrum ved indsættelse og forespørgsel af data, er det nødvendigt at skabe en sammenhæng mellem et vejsegment og koordinatsystemet. Indledningsvist løste vi dette problem med blot at styre indsættelsen af en linje efter dens centrum. (\ref{fig:quadtree2} tv.). Dette forsagede dog et større problem hvor relativt lange linger ikke blev tegnet, da disses centrum sagtens kunne være uden for den besøgte quad. Vores umiddelbare løsning til dette var at tillægge enhver forespørgselsrektangel den halvde længde af den længste linje i den førstspurgte quad. Således var det garanteret, at samtlige linjer, som skar det efterspurgte rektangel, faktisk blev fundet.
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.7\textwidth]{quadtree2}
	\captionsetup{width=0.8\textwidth}
	\caption{Venstre: Linjens centrum afgør hvilken quad den placeres i. Højre: Linjen placeres i enhver quad, som denne skærer.}
	\label{fig:quadtree2}
\end{figure}
Denne implementering medførte, at andre dele af programmet, som gjorde brug af quadtree-strukturen, måtte regne med at modtage overflødig data. Det ville senere vise sig at udgøre et reelt problem for programmets hastighed under rendering. Derfor ændrede vi måden hvorpå linjer indsættes i træet til en mere ideel tilgang, hvor enhver quad som berøres af en linje, indeholder selvsamme. (\ref{fig:quadtree2} th.). Indhentning af et dataområde er således garanteret at returnere de linjer, som enten ligger indenfor eller skærer det eftersøgte område --- og intet andet.

\subsection{Nærmeste vej}
For at opfylde det formelle krav om at synliggøre navnet på vejen nærmest markøren, samt at muliggøre angivelse af start- og slutpunktet for navigation med markøren, måtte en algoritme udarbejdes. Udfordringen bestod i at gennemsøge den rekursive quadtree-struktur i et begrænset område omkring markøren. Hertil sås et løsningsforslag i at finde den dybeste quad, som markøren holdes over, og iterere over dennes indhold. Det medførte dog et problem når markøren befandt sig tæt på en quads horisont, fordi det da ikke kunne garanteres, at den nærmeste vej befandt sig i den fundne quad. I stedet for at løse dette ved at implementere en måde hvorpå nabo-quads kunne findes, valgte vi at udnytte allerede eksisterende funktionalitet til at løse det oprindelige problem. Ved at forespørge den øverste quad om linjer i en begrænset rektangel uden om markøren, og derefter gennemløbe resultatet, kunne den nærmeste linje hurtigt findes. Fandt en forespørgsel ikke nogen linjer fordobledes forespørgselsrektanglet og der forsøgtes igen. Ved at fordoble søgearealet sænkes antallet af nødvendige iterationer uanset om markøren er meget langt væk fra fastlandet eller midt i hovedstaden.
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.5\textwidth]{naermestvej}
	\captionsetup{width=0.8\textwidth}
	\caption{Søgerektanglet fordobles for hver iteration, indtil mindst én linje er fundet.}
	\label{fig:naermestvej}
\end{figure}